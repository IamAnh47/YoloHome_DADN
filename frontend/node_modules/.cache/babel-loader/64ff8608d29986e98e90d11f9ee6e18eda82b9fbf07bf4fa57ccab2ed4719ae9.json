{"ast":null,"code":"import apiService from '../services/apiService';\nclass SystemController {\n  // 5 seconds TTL for cache\n\n  /**\r\n   * Checks if the cached data is still fresh\r\n   * @returns {boolean} True if cache is valid, false if we need fresh data\r\n   */\n  static isDataFresh() {\n    const now = Date.now();\n    return now - this.lastFetchTime < this.cacheTTL;\n  }\n\n  /**\r\n   * Updates the last fetch timestamp\r\n   */\n  static updateFetchTime() {\n    this.lastFetchTime = Date.now();\n  }\n\n  /**\r\n   * Get system status (devices and sensors)\r\n   * @param {boolean} [forceFresh=false] Force refresh data from server\r\n   * @returns {Promise<Object>} All devices and sensor data\r\n   */\n  static async getSystemStatus(forceFresh = false) {\n    try {\n      // If data is not fresh or force refresh is requested, fetch from API\n      if (!this.isDataFresh() || forceFresh) {\n        console.log('Fetching system status from API');\n\n        // Add cache-busting parameter to ensure fresh data\n        const cacheBuster = `?_t=${Date.now()}`;\n        const response = await apiService.get('/status' + cacheBuster);\n        if (response.data && response.data.data) {\n          // Update fetch time\n          this.updateFetchTime();\n          return response.data.data;\n        }\n        console.warn('Invalid API response structure:', JSON.stringify(response.data));\n        throw new Error('Invalid data format from API');\n      } else {\n        console.log('Using cached system status data');\n        return this.getFromCache();\n      }\n    } catch (error) {\n      console.error('Error fetching system status:', error);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Get data from cache (placeholder for future implementation)\r\n   * @returns {Object} Cached data\r\n   */\n  static getFromCache() {\n    // This would be implemented with actual cache storage\n    // For now, we'll just throw an error to force fresh data fetch\n    throw new Error('Cache data unavailable');\n  }\n\n  /**\r\n   * Control the fan\r\n   * @param {boolean} turnOn - true to turn on, false to turn off\r\n   * @returns {Promise<Object>} Control result\r\n   */\n  static async controlFan(turnOn) {\n    try {\n      const action = turnOn ? 'on' : 'off';\n      const response = await apiService.post(`/devices/fan/${action}`);\n\n      // Force refresh system status after a control action\n      await this.getSystemStatus(true);\n      return response.data;\n    } catch (error) {\n      console.error(`Error controlling fan (${turnOn ? 'ON' : 'OFF'}):`, error);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Control the light\r\n   * @param {boolean} turnOn - true to turn on, false to turn off\r\n   * @returns {Promise<Object>} Control result\r\n   */\n  static async controlLight(turnOn) {\n    try {\n      const action = turnOn ? 'on' : 'off';\n      const response = await apiService.post(`/devices/light/${action}`);\n\n      // Force refresh system status after a control action\n      await this.getSystemStatus(true);\n      return response.data;\n    } catch (error) {\n      console.error(`Error controlling light (${turnOn ? 'ON' : 'OFF'}):`, error);\n      throw error;\n    }\n  }\n}\n// Store last fetched timestamp to check data freshness\nSystemController.lastFetchTime = 0;\nSystemController.cacheTTL = 5000;\nexport default SystemController;","map":{"version":3,"names":["apiService","SystemController","isDataFresh","now","Date","lastFetchTime","cacheTTL","updateFetchTime","getSystemStatus","forceFresh","console","log","cacheBuster","response","get","data","warn","JSON","stringify","Error","getFromCache","error","controlFan","turnOn","action","post","controlLight"],"sources":["C:/Users/tuana/University/The_Third_Year/HK242/Đồ án đa ngành/YoloHome_DADN/YoloHome_DADN/frontend/src/controllers/SystemController.js"],"sourcesContent":["import apiService from '../services/apiService';\r\n\r\nclass SystemController {\r\n  // Store last fetched timestamp to check data freshness\r\n  static lastFetchTime = 0;\r\n  static cacheTTL = 5000; // 5 seconds TTL for cache\r\n  \r\n  /**\r\n   * Checks if the cached data is still fresh\r\n   * @returns {boolean} True if cache is valid, false if we need fresh data\r\n   */\r\n  static isDataFresh() {\r\n    const now = Date.now();\r\n    return (now - this.lastFetchTime) < this.cacheTTL;\r\n  }\r\n  \r\n  /**\r\n   * Updates the last fetch timestamp\r\n   */\r\n  static updateFetchTime() {\r\n    this.lastFetchTime = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Get system status (devices and sensors)\r\n   * @param {boolean} [forceFresh=false] Force refresh data from server\r\n   * @returns {Promise<Object>} All devices and sensor data\r\n   */\r\n  static async getSystemStatus(forceFresh = false) {\r\n    try {\r\n      // If data is not fresh or force refresh is requested, fetch from API\r\n      if (!this.isDataFresh() || forceFresh) {\r\n        console.log('Fetching system status from API');\r\n        \r\n        // Add cache-busting parameter to ensure fresh data\r\n        const cacheBuster = `?_t=${Date.now()}`;\r\n        const response = await apiService.get('/status' + cacheBuster);\r\n        \r\n        if (response.data && response.data.data) {\r\n          // Update fetch time\r\n          this.updateFetchTime();\r\n          return response.data.data;\r\n        }\r\n        \r\n        console.warn('Invalid API response structure:', JSON.stringify(response.data));\r\n        throw new Error('Invalid data format from API');\r\n      } else {\r\n        console.log('Using cached system status data');\r\n        return this.getFromCache();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error fetching system status:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get data from cache (placeholder for future implementation)\r\n   * @returns {Object} Cached data\r\n   */\r\n  static getFromCache() {\r\n    // This would be implemented with actual cache storage\r\n    // For now, we'll just throw an error to force fresh data fetch\r\n    throw new Error('Cache data unavailable');\r\n  }\r\n  \r\n  /**\r\n   * Control the fan\r\n   * @param {boolean} turnOn - true to turn on, false to turn off\r\n   * @returns {Promise<Object>} Control result\r\n   */\r\n  static async controlFan(turnOn) {\r\n    try {\r\n      const action = turnOn ? 'on' : 'off';\r\n      const response = await apiService.post(`/devices/fan/${action}`);\r\n      \r\n      // Force refresh system status after a control action\r\n      await this.getSystemStatus(true);\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error(`Error controlling fan (${turnOn ? 'ON' : 'OFF'}):`, error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Control the light\r\n   * @param {boolean} turnOn - true to turn on, false to turn off\r\n   * @returns {Promise<Object>} Control result\r\n   */\r\n  static async controlLight(turnOn) {\r\n    try {\r\n      const action = turnOn ? 'on' : 'off';\r\n      const response = await apiService.post(`/devices/light/${action}`);\r\n      \r\n      // Force refresh system status after a control action\r\n      await this.getSystemStatus(true);\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error(`Error controlling light (${turnOn ? 'ON' : 'OFF'}):`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport default SystemController; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}